{"ast":null,"code":"import { Transaction } from '@solana/web3.js';\nimport { WalletNotConnectedError } from '@solana/wallet-adapter-base';\nexport const getErrorForTransaction = async (connection, txid) => {\n  // wait for all confirmation before geting transaction\n  await connection.confirmTransaction(txid, 'max');\n  const tx = await connection.getParsedConfirmedTransaction(txid);\n  const errors = [];\n\n  if (tx !== null && tx !== void 0 && tx.meta && tx.meta.logMessages) {\n    tx.meta.logMessages.forEach(log => {\n      const regex = /Error: (.*)/gm;\n      let m;\n\n      while ((m = regex.exec(log)) !== null) {\n        // This is necessary to avoid infinite loops with zero-width matches\n        if (m.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n\n        if (m.length > 1) {\n          errors.push(m[1]);\n        }\n      }\n    });\n  }\n\n  return errors;\n};\nexport async function sendTransactionsWithManualRetry(connection, wallet, instructions, signers) {\n  let stopPoint = 0;\n  let tries = 0;\n  let lastInstructionsLength = null;\n  let toRemoveSigners = {};\n  instructions = instructions.filter((instr, i) => {\n    if (instr.length > 0) {\n      return true;\n    } else {\n      toRemoveSigners[i] = true;\n      return false;\n    }\n  });\n  let ids = [];\n  let filteredSigners = signers.filter((_, i) => !toRemoveSigners[i]);\n\n  while (stopPoint < instructions.length && tries < 3) {\n    instructions = instructions.slice(stopPoint, instructions.length);\n    filteredSigners = filteredSigners.slice(stopPoint, filteredSigners.length);\n    if (instructions.length === lastInstructionsLength) tries = tries + 1;else tries = 0;\n\n    try {\n      if (instructions.length === 1) {\n        const id = await sendTransactionWithRetry(connection, wallet, instructions[0], filteredSigners[0], 'single');\n        ids.push(id.txid);\n        stopPoint = 1;\n      } else {\n        const {\n          txs\n        } = await sendTransactions(connection, wallet, instructions, filteredSigners, 'StopOnFailure', 'single');\n        ids = ids.concat(txs.map(t => t.txid));\n      }\n    } catch (e) {\n      console.error(e);\n    }\n\n    console.log('Died on ', stopPoint, 'retrying from instruction', instructions[stopPoint], 'instructions length is', instructions.length);\n    lastInstructionsLength = instructions.length;\n  }\n\n  return ids;\n}\nexport const sendTransactions = async function (connection, wallet, instructionSet, signersSet) {\n  let sequenceType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'Parallel';\n  let commitment = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'singleGossip';\n  let successCallback = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : (txid, ind) => {};\n  let failCallback = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : (txid, ind) => false;\n  let block = arguments.length > 8 ? arguments[8] : undefined;\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n  const unsignedTxns = [];\n\n  if (!block) {\n    block = await connection.getRecentBlockhash(commitment);\n  }\n\n  for (let i = 0; i < instructionSet.length; i++) {\n    const instructions = instructionSet[i];\n    const signers = signersSet[i];\n\n    if (instructions.length === 0) {\n      continue;\n    }\n\n    let transaction = new Transaction();\n    instructions.forEach(instruction => transaction.add(instruction));\n    transaction.recentBlockhash = block.blockhash;\n    transaction.setSigners( // fee payed by the wallet owner\n    wallet.publicKey, ...signers.map(s => s.publicKey));\n\n    if (signers.length > 0) {\n      transaction.partialSign(...signers);\n    }\n\n    unsignedTxns.push(transaction);\n  }\n\n  const signedTxns = await wallet.signAllTransactions(unsignedTxns);\n  const pendingTxns = [];\n  let breakEarlyObject = {\n    breakEarly: false,\n    i: 0\n  };\n  console.log('Signed txns length', signedTxns.length, 'vs handed in length', instructionSet.length);\n\n  for (let i = 0; i < signedTxns.length; i++) {\n    const signedTxnPromise = sendSignedTransaction({\n      connection,\n      signedTransaction: signedTxns[i]\n    });\n    signedTxnPromise.then(_ref => {\n      let {\n        txid,\n        slot\n      } = _ref;\n      successCallback(txid, i);\n    }).catch(reason => {\n      failCallback(signedTxns[i], i);\n\n      if (sequenceType === 'StopOnFailure') {\n        breakEarlyObject.breakEarly = true;\n        breakEarlyObject.i = i;\n      }\n    });\n\n    if (sequenceType !== 'Parallel') {\n      try {\n        await signedTxnPromise;\n      } catch (e) {\n        console.log('Caught failure', e);\n\n        if (breakEarlyObject.breakEarly) {\n          console.log('Died on ', breakEarlyObject.i); // Return the txn we failed on by index\n\n          return {\n            number: breakEarlyObject.i,\n            txs: await Promise.all(pendingTxns)\n          };\n        }\n      }\n    } else {\n      pendingTxns.push(signedTxnPromise);\n    }\n  }\n\n  if (sequenceType !== 'Parallel') {\n    await Promise.all(pendingTxns);\n  }\n\n  return {\n    number: signedTxns.length,\n    txs: await Promise.all(pendingTxns)\n  };\n};\nexport const sendTransaction = async function (connection, wallet, instructions, signers) {\n  let awaitConfirmation = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n  let commitment = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'singleGossip';\n  let includesFeePayer = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n  let block = arguments.length > 7 ? arguments[7] : undefined;\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n  let transaction = new Transaction();\n  instructions.forEach(instruction => transaction.add(instruction));\n  transaction.recentBlockhash = (block || (await connection.getRecentBlockhash(commitment))).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map(s => s.publicKey));\n  } else {\n    transaction.setSigners( // fee payed by the wallet owner\n    wallet.publicKey, ...signers.map(s => s.publicKey));\n  }\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n\n  if (!includesFeePayer) {\n    transaction = await wallet.signTransaction(transaction);\n  }\n\n  const rawTransaction = transaction.serialize();\n  let options = {\n    skipPreflight: true,\n    commitment\n  };\n  const txid = await connection.sendRawTransaction(rawTransaction, options);\n  let slot = 0;\n\n  if (awaitConfirmation) {\n    const confirmation = await awaitTransactionSignatureConfirmation(txid, DEFAULT_TIMEOUT, connection, commitment);\n    if (!confirmation) throw new Error('Timed out awaiting confirmation on transaction');\n    slot = (confirmation === null || confirmation === void 0 ? void 0 : confirmation.slot) || 0;\n\n    if (confirmation !== null && confirmation !== void 0 && confirmation.err) {\n      const errors = await getErrorForTransaction(connection, txid);\n      console.log(errors);\n      throw new Error(`Raw transaction ${txid} failed`);\n    }\n  }\n\n  return {\n    txid,\n    slot\n  };\n};\nexport const sendTransactionWithRetry = async function (connection, wallet, instructions, signers) {\n  let commitment = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'singleGossip';\n  let includesFeePayer = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  let block = arguments.length > 6 ? arguments[6] : undefined;\n  let beforeSend = arguments.length > 7 ? arguments[7] : undefined;\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n  let transaction = new Transaction();\n  instructions.forEach(instruction => transaction.add(instruction));\n  transaction.recentBlockhash = (block || (await connection.getRecentBlockhash(commitment))).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map(s => s.publicKey));\n  } else {\n    transaction.setSigners( // fee payed by the wallet owner\n    wallet.publicKey, ...signers.map(s => s.publicKey));\n  }\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n\n  if (!includesFeePayer) {\n    transaction = await wallet.signTransaction(transaction);\n  }\n\n  if (beforeSend) {\n    beforeSend();\n  }\n\n  const {\n    txid,\n    slot\n  } = await sendSignedTransaction({\n    connection,\n    signedTransaction: transaction\n  });\n  return {\n    txid,\n    slot\n  };\n};\nexport const getUnixTs = () => {\n  return new Date().getTime() / 1000;\n};\nconst DEFAULT_TIMEOUT = 15000;\nexport async function sendSignedTransaction(_ref2) {\n  let {\n    signedTransaction,\n    connection,\n    timeout = DEFAULT_TIMEOUT\n  } = _ref2;\n  const rawTransaction = signedTransaction.serialize();\n  const startTime = getUnixTs();\n  let slot = 0;\n  const txid = await connection.sendRawTransaction(rawTransaction, {\n    skipPreflight: true\n  });\n  console.log('Started awaiting confirmation for', txid);\n  let done = false;\n\n  (async () => {\n    while (!done && getUnixTs() - startTime < timeout) {\n      connection.sendRawTransaction(rawTransaction, {\n        skipPreflight: true\n      });\n      await sleep(500);\n    }\n  })();\n\n  try {\n    const confirmation = await awaitTransactionSignatureConfirmation(txid, timeout, connection, 'recent', true);\n    if (!confirmation) throw new Error('Timed out awaiting confirmation on transaction');\n\n    if (confirmation.err) {\n      console.error(confirmation.err);\n      throw new Error('Transaction failed: Custom instruction error');\n    }\n\n    slot = (confirmation === null || confirmation === void 0 ? void 0 : confirmation.slot) || 0;\n  } catch (err) {\n    console.error('Timeout Error caught', err);\n\n    if (err.timeout) {\n      throw new Error('Timed out awaiting confirmation on transaction');\n    }\n\n    let simulateResult = null;\n\n    try {\n      simulateResult = (await simulateTransaction(connection, signedTransaction, 'single')).value;\n    } catch (e) {}\n\n    if (simulateResult && simulateResult.err) {\n      if (simulateResult.logs) {\n        for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\n          const line = simulateResult.logs[i];\n\n          if (line.startsWith('Program log: ')) {\n            throw new Error('Transaction failed: ' + line.slice('Program log: '.length));\n          }\n        }\n      }\n\n      throw new Error(JSON.stringify(simulateResult.err));\n    } // throw new Error('Transaction failed');\n\n  } finally {\n    done = true;\n  }\n\n  console.log('Latency', txid, getUnixTs() - startTime);\n  return {\n    txid,\n    slot\n  };\n}\n\nasync function simulateTransaction(connection, transaction, commitment) {\n  // @ts-ignore\n  transaction.recentBlockhash = await connection._recentBlockhash( // @ts-ignore\n  connection._disableBlockhashCaching);\n  const signData = transaction.serializeMessage(); // @ts-ignore\n\n  const wireTransaction = transaction._serialize(signData);\n\n  const encodedTransaction = wireTransaction.toString('base64');\n  const config = {\n    encoding: 'base64',\n    commitment\n  };\n  const args = [encodedTransaction, config]; // @ts-ignore\n\n  const res = await connection._rpcRequest('simulateTransaction', args);\n\n  if (res.error) {\n    throw new Error('failed to simulate transaction: ' + res.error.message);\n  }\n\n  return res.result;\n}\n\nasync function awaitTransactionSignatureConfirmation(txid, timeout, connection) {\n  let commitment = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'recent';\n  let queryStatus = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  let done = false;\n  let status = {\n    slot: 0,\n    confirmations: 0,\n    err: null\n  };\n  let subId = 0;\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n\n      done = true;\n      console.log('Rejecting for timeout...');\n      reject({\n        timeout: true\n      });\n    }, timeout);\n\n    try {\n      subId = connection.onSignature(txid, (result, context) => {\n        done = true;\n        status = {\n          err: result.err,\n          slot: context.slot,\n          confirmations: 0\n        };\n\n        if (result.err) {\n          console.log('Rejected via websocket', result.err);\n          reject(status);\n        } else {\n          console.log('Resolved via websocket', result);\n          resolve(status);\n        }\n      }, commitment);\n    } catch (e) {\n      done = true;\n      console.error('WS error in setup', txid, e);\n    }\n\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([txid]);\n          status = signatureStatuses && signatureStatuses.value[0];\n\n          if (!done) {\n            if (!status) {\n              console.log('REST null result for', txid, status);\n            } else if (status.err) {\n              console.log('REST error for', txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              console.log('REST no confirmations for', txid, status);\n            } else {\n              console.log('REST confirmation for', txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            console.log('REST connection error: txid', txid, e);\n          }\n        }\n      })();\n\n      await sleep(2000);\n    }\n  }); //@ts-ignore\n\n  if (connection._signatureSubscriptions[subId]) connection.removeSignatureListener(subId);\n  done = true;\n  console.log('Returning status', status);\n  return status;\n}\n\nexport function sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}","map":{"version":3,"sources":["/Users/bryan/solana-gif-portal/app/src/components/NftDrop/app/src/CandyMachine/connection.js"],"names":["Transaction","WalletNotConnectedError","getErrorForTransaction","connection","txid","confirmTransaction","tx","getParsedConfirmedTransaction","errors","meta","logMessages","forEach","log","regex","m","exec","index","lastIndex","length","push","sendTransactionsWithManualRetry","wallet","instructions","signers","stopPoint","tries","lastInstructionsLength","toRemoveSigners","filter","instr","i","ids","filteredSigners","_","slice","id","sendTransactionWithRetry","txs","sendTransactions","concat","map","t","e","console","error","instructionSet","signersSet","sequenceType","commitment","successCallback","ind","failCallback","block","publicKey","unsignedTxns","getRecentBlockhash","transaction","instruction","add","recentBlockhash","blockhash","setSigners","s","partialSign","signedTxns","signAllTransactions","pendingTxns","breakEarlyObject","breakEarly","signedTxnPromise","sendSignedTransaction","signedTransaction","then","slot","catch","reason","number","Promise","all","sendTransaction","awaitConfirmation","includesFeePayer","signTransaction","rawTransaction","serialize","options","skipPreflight","sendRawTransaction","confirmation","awaitTransactionSignatureConfirmation","DEFAULT_TIMEOUT","Error","err","beforeSend","getUnixTs","Date","getTime","timeout","startTime","done","sleep","simulateResult","simulateTransaction","value","logs","line","startsWith","JSON","stringify","_recentBlockhash","_disableBlockhashCaching","signData","serializeMessage","wireTransaction","_serialize","encodedTransaction","toString","config","encoding","args","res","_rpcRequest","message","result","queryStatus","status","confirmations","subId","resolve","reject","setTimeout","onSignature","context","signatureStatuses","getSignatureStatuses","_signatureSubscriptions","removeSignatureListener","ms"],"mappings":"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","sourcesContent":["import { Transaction } from '@solana/web3.js';\n\nimport { WalletNotConnectedError } from '@solana/wallet-adapter-base';\n\nexport const getErrorForTransaction = async (\n  connection,\n  txid\n) => {\n  // wait for all confirmation before geting transaction\n  await connection.confirmTransaction(txid, 'max');\n\n  const tx = await connection.getParsedConfirmedTransaction(txid);\n\n  const errors = [];\n  if (tx?.meta && tx.meta.logMessages) {\n    tx.meta.logMessages.forEach(log => {\n      const regex = /Error: (.*)/gm;\n      let m;\n      while ((m = regex.exec(log)) !== null) {\n        // This is necessary to avoid infinite loops with zero-width matches\n        if (m.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n\n        if (m.length > 1) {\n          errors.push(m[1]);\n        }\n      }\n    });\n  }\n\n  return errors;\n};\n\n\nexport async function sendTransactionsWithManualRetry(\n  connection,\n  wallet,\n  instructions,\n  signers,\n){\n  let stopPoint = 0;\n  let tries = 0;\n  let lastInstructionsLength = null;\n  let toRemoveSigners = {};\n  instructions = instructions.filter((instr, i) => {\n    if (instr.length > 0) {\n      return true;\n    } else {\n      toRemoveSigners[i] = true;\n      return false;\n    }\n  });\n  let ids = [];\n  let filteredSigners = signers.filter((_, i) => !toRemoveSigners[i]);\n\n  while (stopPoint < instructions.length && tries < 3) {\n    instructions = instructions.slice(stopPoint, instructions.length);\n    filteredSigners = filteredSigners.slice(stopPoint, filteredSigners.length);\n\n    if (instructions.length === lastInstructionsLength) tries = tries + 1;\n    else tries = 0;\n\n    try {\n      if (instructions.length === 1) {\n        const id = await sendTransactionWithRetry(\n          connection,\n          wallet,\n          instructions[0],\n          filteredSigners[0],\n          'single',\n        );\n        ids.push(id.txid);\n        stopPoint = 1;\n      } else {\n        const { txs } = await sendTransactions(\n          connection,\n          wallet,\n          instructions,\n          filteredSigners,\n          'StopOnFailure',\n          'single',\n        );\n        ids = ids.concat(txs.map(t => t.txid));\n      }\n    } catch (e) {\n      console.error(e);\n    }\n    console.log(\n      'Died on ',\n      stopPoint,\n      'retrying from instruction',\n      instructions[stopPoint],\n      'instructions length is',\n      instructions.length,\n    );\n    lastInstructionsLength = instructions.length;\n  }\n\n  return ids;\n}\n\nexport const sendTransactions = async (\n  connection,\n  wallet,\n  instructionSet,\n  signersSet,\n  sequenceType = 'Parallel',\n  commitment = 'singleGossip',\n  successCallback = (txid, ind) => {},\n  failCallback = (txid, ind) => false,\n  block,\n) => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  const unsignedTxns = [];\n\n  if (!block) {\n    block = await connection.getRecentBlockhash(commitment);\n  }\n\n  for (let i = 0; i < instructionSet.length; i++) {\n    const instructions = instructionSet[i];\n    const signers = signersSet[i];\n\n    if (instructions.length === 0) {\n      continue;\n    }\n\n    let transaction = new Transaction();\n    instructions.forEach(instruction => transaction.add(instruction));\n    transaction.recentBlockhash = block.blockhash;\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map(s => s.publicKey),\n    );\n\n    if (signers.length > 0) {\n      transaction.partialSign(...signers);\n    }\n\n    unsignedTxns.push(transaction);\n  }\n\n  const signedTxns = await wallet.signAllTransactions(unsignedTxns);\n\n  const pendingTxns= [];\n\n  let breakEarlyObject = { breakEarly: false, i: 0 };\n  console.log(\n    'Signed txns length',\n    signedTxns.length,\n    'vs handed in length',\n    instructionSet.length,\n  );\n  for (let i = 0; i < signedTxns.length; i++) {\n    const signedTxnPromise = sendSignedTransaction({\n      connection,\n      signedTransaction: signedTxns[i],\n    });\n\n    signedTxnPromise\n      .then(({ txid, slot }) => {\n        successCallback(txid, i);\n      })\n      .catch(reason => {\n        failCallback(signedTxns[i], i);\n        if (sequenceType === 'StopOnFailure') {\n          breakEarlyObject.breakEarly = true;\n          breakEarlyObject.i = i;\n        }\n      });\n\n    if (sequenceType !== 'Parallel') {\n      try {\n        await signedTxnPromise;\n      } catch (e) {\n        console.log('Caught failure', e);\n        if (breakEarlyObject.breakEarly) {\n          console.log('Died on ', breakEarlyObject.i);\n          // Return the txn we failed on by index\n          return {\n            number: breakEarlyObject.i,\n            txs: await Promise.all(pendingTxns),\n          };\n        }\n      }\n    } else {\n      pendingTxns.push(signedTxnPromise);\n    }\n  }\n\n  if (sequenceType !== 'Parallel') {\n    await Promise.all(pendingTxns);\n  }\n\n  return { number: signedTxns.length, txs: await Promise.all(pendingTxns) };\n};\n\nexport const sendTransaction = async (\n  connection,\n  wallet,\n  instructions,\n  signers,\n  awaitConfirmation = true,\n  commitment = 'singleGossip',\n  includesFeePayer = false,\n  block,\n) => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  let transaction = new Transaction();\n  instructions.forEach(instruction => transaction.add(instruction));\n  transaction.recentBlockhash = (\n    block || (await connection.getRecentBlockhash(commitment))\n  ).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map(s => s.publicKey));\n  } else {\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map(s => s.publicKey),\n    );\n  }\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n  if (!includesFeePayer) {\n    transaction = await wallet.signTransaction(transaction);\n  }\n\n  const rawTransaction = transaction.serialize();\n  let options = {\n    skipPreflight: true,\n    commitment,\n  };\n\n  const txid = await connection.sendRawTransaction(rawTransaction, options);\n  let slot = 0;\n\n  if (awaitConfirmation) {\n    const confirmation = await awaitTransactionSignatureConfirmation(\n      txid,\n      DEFAULT_TIMEOUT,\n      connection,\n      commitment,\n    );\n\n    if (!confirmation)\n      throw new Error('Timed out awaiting confirmation on transaction');\n    slot = confirmation?.slot || 0;\n\n    if (confirmation?.err) {\n      const errors = await getErrorForTransaction(connection, txid);\n\n      console.log(errors);\n      throw new Error(`Raw transaction ${txid} failed`);\n    }\n  }\n\n  return { txid, slot };\n};\n\nexport const sendTransactionWithRetry = async (\n  connection,\n  wallet,\n  instructions,\n  signers,\n  commitment = 'singleGossip',\n  includesFeePayer = false,\n  block,\n  beforeSend,\n) => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  let transaction = new Transaction();\n  instructions.forEach(instruction => transaction.add(instruction));\n  transaction.recentBlockhash = (\n    block || (await connection.getRecentBlockhash(commitment))\n  ).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map(s => s.publicKey));\n  } else {\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map(s => s.publicKey),\n    );\n  }\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n  if (!includesFeePayer) {\n    transaction = await wallet.signTransaction(transaction);\n  }\n\n  if (beforeSend) {\n    beforeSend();\n  }\n\n  const { txid, slot } = await sendSignedTransaction({\n    connection,\n    signedTransaction: transaction,\n  });\n\n  return { txid, slot };\n};\n\nexport const getUnixTs = () => {\n  return new Date().getTime() / 1000;\n};\n\nconst DEFAULT_TIMEOUT = 15000;\n\nexport async function sendSignedTransaction({\n  signedTransaction,\n  connection,\n  timeout = DEFAULT_TIMEOUT,\n}) {\n  const rawTransaction = signedTransaction.serialize();\n  const startTime = getUnixTs();\n  let slot = 0;\n  const txid = await connection.sendRawTransaction(\n    rawTransaction,\n    {\n      skipPreflight: true,\n    },\n  );\n\n  console.log('Started awaiting confirmation for', txid);\n\n  let done = false;\n  (async () => {\n    while (!done && getUnixTs() - startTime < timeout) {\n      connection.sendRawTransaction(rawTransaction, {\n        skipPreflight: true,\n      });\n      await sleep(500);\n    }\n  })();\n  try {\n    const confirmation = await awaitTransactionSignatureConfirmation(\n      txid,\n      timeout,\n      connection,\n      'recent',\n      true,\n    );\n\n    if (!confirmation)\n      throw new Error('Timed out awaiting confirmation on transaction');\n\n    if (confirmation.err) {\n      console.error(confirmation.err);\n      throw new Error('Transaction failed: Custom instruction error');\n    }\n\n    slot = confirmation?.slot || 0;\n  } catch (err) {\n    console.error('Timeout Error caught', err);\n    if (err.timeout) {\n      throw new Error('Timed out awaiting confirmation on transaction');\n    }\n    let simulateResult = null;\n    try {\n      simulateResult = (\n        await simulateTransaction(connection, signedTransaction, 'single')\n      ).value;\n    } catch (e) {}\n    if (simulateResult && simulateResult.err) {\n      if (simulateResult.logs) {\n        for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\n          const line = simulateResult.logs[i];\n          if (line.startsWith('Program log: ')) {\n            throw new Error(\n              'Transaction failed: ' + line.slice('Program log: '.length),\n            );\n          }\n        }\n      }\n      throw new Error(JSON.stringify(simulateResult.err));\n    }\n    // throw new Error('Transaction failed');\n  } finally {\n    done = true;\n  }\n\n  console.log('Latency', txid, getUnixTs() - startTime);\n  return { txid, slot };\n}\n\nasync function simulateTransaction(\n  connection,\n  transaction,\n  commitment,\n) {\n  // @ts-ignore\n  transaction.recentBlockhash = await connection._recentBlockhash(\n    // @ts-ignore\n    connection._disableBlockhashCaching,\n  );\n\n  const signData = transaction.serializeMessage();\n  // @ts-ignore\n  const wireTransaction = transaction._serialize(signData);\n  const encodedTransaction = wireTransaction.toString('base64');\n  const config = { encoding: 'base64', commitment };\n  const args = [encodedTransaction, config];\n\n  // @ts-ignore\n  const res = await connection._rpcRequest('simulateTransaction', args);\n  if (res.error) {\n    throw new Error('failed to simulate transaction: ' + res.error.message);\n  }\n  return res.result;\n}\n\nasync function awaitTransactionSignatureConfirmation(\n  txid,\n  timeout,\n  connection,\n  commitment = 'recent',\n  queryStatus = false,\n){\n  let done = false;\n  let status = {\n    slot: 0,\n    confirmations: 0,\n    err: null,\n  };\n  let subId = 0;\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n      done = true;\n      console.log('Rejecting for timeout...');\n      reject({ timeout: true });\n    }, timeout);\n    try {\n      subId = connection.onSignature(\n        txid,\n        (result, context) => {\n          done = true;\n          status = {\n            err: result.err,\n            slot: context.slot,\n            confirmations: 0,\n          };\n          if (result.err) {\n            console.log('Rejected via websocket', result.err);\n            reject(status);\n          } else {\n            console.log('Resolved via websocket', result);\n            resolve(status);\n          }\n        },\n        commitment,\n      );\n    } catch (e) {\n      done = true;\n      console.error('WS error in setup', txid, e);\n    }\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([\n            txid,\n          ]);\n          status = signatureStatuses && signatureStatuses.value[0];\n          if (!done) {\n            if (!status) {\n              console.log('REST null result for', txid, status);\n            } else if (status.err) {\n              console.log('REST error for', txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              console.log('REST no confirmations for', txid, status);\n            } else {\n              console.log('REST confirmation for', txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            console.log('REST connection error: txid', txid, e);\n          }\n        }\n      })();\n      await sleep(2000);\n    }\n  });\n\n  //@ts-ignore\n  if (connection._signatureSubscriptions[subId])\n    connection.removeSignatureListener(subId);\n  done = true;\n  console.log('Returning status', status);\n  return status;\n}\nexport function sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n"]},"metadata":{},"sourceType":"module"}